// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StorySearchResult A Story in search results. This is typed differently from Story because the details=slim search argument will omit some fields.
//
// swagger:model StorySearchResult
type StorySearchResult struct {

	// The Shortcut application url for the Story.
	// Required: true
	AppURL *string `json:"app_url"`

	// True if the story has been archived or not.
	// Required: true
	Archived *bool `json:"archived"`

	// A true/false boolean indicating if the Story is currently blocked.
	// Required: true
	Blocked *bool `json:"blocked"`

	// A true/false boolean indicating if the Story is currently a blocker of another story.
	// Required: true
	Blocker *bool `json:"blocker"`

	// An array of Git branches attached to the story.
	Branches []*Branch `json:"branches"`

	// An array of IDs of Comments attached to the story.
	CommentIds []int64 `json:"comment_ids"`

	// An array of comments attached to the story.
	Comments []*StoryComment `json:"comments"`

	// An array of commits attached to the story.
	Commits []*Commit `json:"commits"`

	// A true/false boolean indicating if the Story has been completed.
	// Required: true
	Completed *bool `json:"completed"`

	// The time/date the Story was completed.
	// Required: true
	// Format: date-time
	CompletedAt *strfmt.DateTime `json:"completed_at"`

	// A manual override for the time/date the Story was completed.
	// Required: true
	// Format: date-time
	CompletedAtOverride *strfmt.DateTime `json:"completed_at_override"`

	// The time/date the Story was created.
	// Required: true
	// Format: date-time
	CreatedAt *strfmt.DateTime `json:"created_at"`

	// An array of CustomField value assertions for the story.
	CustomFields []*StoryCustomField `json:"custom_fields"`

	// The cycle time (in seconds) of this story when complete.
	CycleTime int64 `json:"cycle_time,omitempty"`

	// The due date of the story.
	// Required: true
	// Format: date-time
	Deadline *strfmt.DateTime `json:"deadline"`

	// The description of the story.
	Description string `json:"description,omitempty"`

	// A string description of this resource.
	// Required: true
	EntityType *string `json:"entity_type"`

	// The ID of the epic the story belongs to.
	// Required: true
	EpicID *int64 `json:"epic_id"`

	// The numeric point estimate of the story. Can also be null, which means unestimated.
	// Required: true
	Estimate *int64 `json:"estimate"`

	// This field can be set to another unique ID. In the case that the Story has been imported from another tool, the ID in the other tool can be indicated here.
	// Required: true
	ExternalID *string `json:"external_id"`

	// An array of external links (strings) associated with a Story
	// Required: true
	ExternalLinks []string `json:"external_links"`

	// An array of IDs of Files attached to the story.
	FileIds []int64 `json:"file_ids"`

	// An array of files attached to the story.
	Files []*UploadedFile `json:"files"`

	// An array of UUIDs for any Members listed as Followers.
	// Required: true
	FollowerIds []strfmt.UUID `json:"follower_ids"`

	// global id
	// Required: true
	GlobalID *string `json:"global_id"`

	// The ID of the group associated with the story.
	// Required: true
	// Format: uuid
	GroupID *strfmt.UUID `json:"group_id"`

	// An array of Group IDs that have been mentioned in the Story description.
	// Required: true
	GroupMentionIds []strfmt.UUID `json:"group_mention_ids"`

	// The unique ID of the Story.
	// Required: true
	ID *int64 `json:"id"`

	// The ID of the iteration the story belongs to.
	// Required: true
	IterationID *int64 `json:"iteration_id"`

	// An array of label ids attached to the story.
	// Required: true
	LabelIds []int64 `json:"label_ids"`

	// An array of labels attached to the story.
	// Required: true
	Labels []*LabelSlim `json:"labels"`

	// The lead time (in seconds) of this story when complete.
	LeadTime int64 `json:"lead_time,omitempty"`

	// An array of IDs of LinkedFiles attached to the story.
	LinkedFileIds []int64 `json:"linked_file_ids"`

	// An array of linked files attached to the story.
	LinkedFiles []*LinkedFile `json:"linked_files"`

	// An array of Member IDs that have been mentioned in the Story description.
	// Required: true
	MemberMentionIds []strfmt.UUID `json:"member_mention_ids"`

	// `Deprecated:` use `member_mention_ids`.
	// Required: true
	MentionIds []strfmt.UUID `json:"mention_ids"`

	// The time/date the Story was last changed workflow-state.
	// Required: true
	// Format: date-time
	MovedAt *strfmt.DateTime `json:"moved_at"`

	// The name of the story.
	// Required: true
	Name *string `json:"name"`

	// The number of tasks on the story which are complete.
	NumTasksCompleted int64 `json:"num_tasks_completed,omitempty"`

	// An array of UUIDs of the owners of this story.
	// Required: true
	OwnerIds []strfmt.UUID `json:"owner_ids"`

	// A number representing the position of the story in relation to every other story in the current project.
	// Required: true
	Position *int64 `json:"position"`

	// The IDs of the iteration the story belongs to.
	// Required: true
	PreviousIterationIds []int64 `json:"previous_iteration_ids"`

	// The ID of the project the story belongs to.
	// Required: true
	ProjectID *int64 `json:"project_id"`

	// An array of Pull/Merge Requests attached to the story.
	PullRequests []*PullRequest `json:"pull_requests"`

	// The ID of the Member that requested the story.
	// Required: true
	// Format: uuid
	RequestedByID *strfmt.UUID `json:"requested_by_id"`

	// A true/false boolean indicating if the Story has been started.
	// Required: true
	Started *bool `json:"started"`

	// The time/date the Story was started.
	// Required: true
	// Format: date-time
	StartedAt *strfmt.DateTime `json:"started_at"`

	// A manual override for the time/date the Story was started.
	// Required: true
	// Format: date-time
	StartedAtOverride *strfmt.DateTime `json:"started_at_override"`

	// stats
	// Required: true
	Stats *StoryStats `json:"stats"`

	// An array of story links attached to the Story.
	// Required: true
	StoryLinks []*TypedStoryLink `json:"story_links"`

	// The ID of the story template used to create this story, or null if not created using a template.
	// Required: true
	// Format: uuid
	StoryTemplateID *strfmt.UUID `json:"story_template_id"`

	// The type of story (feature, bug, chore).
	// Required: true
	StoryType *string `json:"story_type"`

	// synced item
	SyncedItem *SyncedItem `json:"synced_item,omitempty"`

	// An array of IDs of Tasks attached to the story.
	TaskIds []int64 `json:"task_ids"`

	// An array of tasks connected to the story.
	Tasks []*Task `json:"tasks"`

	// The IDs of any unresolved blocker comments on the Story.
	UnresolvedBlockerComments []int64 `json:"unresolved_blocker_comments"`

	// The time/date the Story was updated.
	// Required: true
	// Format: date-time
	UpdatedAt *strfmt.DateTime `json:"updated_at"`

	// The ID of the workflow the story belongs to.
	// Required: true
	WorkflowID *int64 `json:"workflow_id"`

	// The ID of the workflow state the story is currently in.
	// Required: true
	WorkflowStateID *int64 `json:"workflow_state_id"`
}

// Validate validates this story search result
func (m *StorySearchResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchived(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlocked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlocker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBranches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletedAtOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomFields(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeadline(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEpicID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEstimate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFollowerIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupMentionIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIterationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabelIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemberMentionIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMentionIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMovedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnerIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreviousIterationIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePullRequests(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestedByID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStarted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedAtOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoryLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoryTemplateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyncedItem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkflowID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkflowStateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StorySearchResult) validateAppURL(formats strfmt.Registry) error {

	if err := validate.Required("app_url", "body", m.AppURL); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateArchived(formats strfmt.Registry) error {

	if err := validate.Required("archived", "body", m.Archived); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateBlocked(formats strfmt.Registry) error {

	if err := validate.Required("blocked", "body", m.Blocked); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateBlocker(formats strfmt.Registry) error {

	if err := validate.Required("blocker", "body", m.Blocker); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateBranches(formats strfmt.Registry) error {
	if swag.IsZero(m.Branches) { // not required
		return nil
	}

	for i := 0; i < len(m.Branches); i++ {
		if swag.IsZero(m.Branches[i]) { // not required
			continue
		}

		if m.Branches[i] != nil {
			if err := m.Branches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("branches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("branches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(m.Comments) { // not required
		return nil
	}

	for i := 0; i < len(m.Comments); i++ {
		if swag.IsZero(m.Comments[i]) { // not required
			continue
		}

		if m.Comments[i] != nil {
			if err := m.Comments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("comments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("comments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateCommits(formats strfmt.Registry) error {
	if swag.IsZero(m.Commits) { // not required
		return nil
	}

	for i := 0; i < len(m.Commits); i++ {
		if swag.IsZero(m.Commits[i]) { // not required
			continue
		}

		if m.Commits[i] != nil {
			if err := m.Commits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commits" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateCompleted(formats strfmt.Registry) error {

	if err := validate.Required("completed", "body", m.Completed); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateCompletedAt(formats strfmt.Registry) error {

	if err := validate.Required("completed_at", "body", m.CompletedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("completed_at", "body", "date-time", m.CompletedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateCompletedAtOverride(formats strfmt.Registry) error {

	if err := validate.Required("completed_at_override", "body", m.CompletedAtOverride); err != nil {
		return err
	}

	if err := validate.FormatOf("completed_at_override", "body", "date-time", m.CompletedAtOverride.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateCreatedAt(formats strfmt.Registry) error {

	if err := validate.Required("created_at", "body", m.CreatedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateCustomFields(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomFields) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomFields); i++ {
		if swag.IsZero(m.CustomFields[i]) { // not required
			continue
		}

		if m.CustomFields[i] != nil {
			if err := m.CustomFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("custom_fields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("custom_fields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateDeadline(formats strfmt.Registry) error {

	if err := validate.Required("deadline", "body", m.Deadline); err != nil {
		return err
	}

	if err := validate.FormatOf("deadline", "body", "date-time", m.Deadline.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateEntityType(formats strfmt.Registry) error {

	if err := validate.Required("entity_type", "body", m.EntityType); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateEpicID(formats strfmt.Registry) error {

	if err := validate.Required("epic_id", "body", m.EpicID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateEstimate(formats strfmt.Registry) error {

	if err := validate.Required("estimate", "body", m.Estimate); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateExternalID(formats strfmt.Registry) error {

	if err := validate.Required("external_id", "body", m.ExternalID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateExternalLinks(formats strfmt.Registry) error {

	if err := validate.Required("external_links", "body", m.ExternalLinks); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.Files) { // not required
		return nil
	}

	for i := 0; i < len(m.Files); i++ {
		if swag.IsZero(m.Files[i]) { // not required
			continue
		}

		if m.Files[i] != nil {
			if err := m.Files[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateFollowerIds(formats strfmt.Registry) error {

	if err := validate.Required("follower_ids", "body", m.FollowerIds); err != nil {
		return err
	}

	for i := 0; i < len(m.FollowerIds); i++ {

		if err := validate.FormatOf("follower_ids"+"."+strconv.Itoa(i), "body", "uuid", m.FollowerIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *StorySearchResult) validateGlobalID(formats strfmt.Registry) error {

	if err := validate.Required("global_id", "body", m.GlobalID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateGroupID(formats strfmt.Registry) error {

	if err := validate.Required("group_id", "body", m.GroupID); err != nil {
		return err
	}

	if err := validate.FormatOf("group_id", "body", "uuid", m.GroupID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateGroupMentionIds(formats strfmt.Registry) error {

	if err := validate.Required("group_mention_ids", "body", m.GroupMentionIds); err != nil {
		return err
	}

	for i := 0; i < len(m.GroupMentionIds); i++ {

		if err := validate.FormatOf("group_mention_ids"+"."+strconv.Itoa(i), "body", "uuid", m.GroupMentionIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *StorySearchResult) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateIterationID(formats strfmt.Registry) error {

	if err := validate.Required("iteration_id", "body", m.IterationID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateLabelIds(formats strfmt.Registry) error {

	if err := validate.Required("label_ids", "body", m.LabelIds); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateLabels(formats strfmt.Registry) error {

	if err := validate.Required("labels", "body", m.Labels); err != nil {
		return err
	}

	for i := 0; i < len(m.Labels); i++ {
		if swag.IsZero(m.Labels[i]) { // not required
			continue
		}

		if m.Labels[i] != nil {
			if err := m.Labels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateLinkedFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkedFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.LinkedFiles); i++ {
		if swag.IsZero(m.LinkedFiles[i]) { // not required
			continue
		}

		if m.LinkedFiles[i] != nil {
			if err := m.LinkedFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("linked_files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("linked_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateMemberMentionIds(formats strfmt.Registry) error {

	if err := validate.Required("member_mention_ids", "body", m.MemberMentionIds); err != nil {
		return err
	}

	for i := 0; i < len(m.MemberMentionIds); i++ {

		if err := validate.FormatOf("member_mention_ids"+"."+strconv.Itoa(i), "body", "uuid", m.MemberMentionIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *StorySearchResult) validateMentionIds(formats strfmt.Registry) error {

	if err := validate.Required("mention_ids", "body", m.MentionIds); err != nil {
		return err
	}

	for i := 0; i < len(m.MentionIds); i++ {

		if err := validate.FormatOf("mention_ids"+"."+strconv.Itoa(i), "body", "uuid", m.MentionIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *StorySearchResult) validateMovedAt(formats strfmt.Registry) error {

	if err := validate.Required("moved_at", "body", m.MovedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("moved_at", "body", "date-time", m.MovedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateOwnerIds(formats strfmt.Registry) error {

	if err := validate.Required("owner_ids", "body", m.OwnerIds); err != nil {
		return err
	}

	for i := 0; i < len(m.OwnerIds); i++ {

		if err := validate.FormatOf("owner_ids"+"."+strconv.Itoa(i), "body", "uuid", m.OwnerIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *StorySearchResult) validatePosition(formats strfmt.Registry) error {

	if err := validate.Required("position", "body", m.Position); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validatePreviousIterationIds(formats strfmt.Registry) error {

	if err := validate.Required("previous_iteration_ids", "body", m.PreviousIterationIds); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateProjectID(formats strfmt.Registry) error {

	if err := validate.Required("project_id", "body", m.ProjectID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validatePullRequests(formats strfmt.Registry) error {
	if swag.IsZero(m.PullRequests) { // not required
		return nil
	}

	for i := 0; i < len(m.PullRequests); i++ {
		if swag.IsZero(m.PullRequests[i]) { // not required
			continue
		}

		if m.PullRequests[i] != nil {
			if err := m.PullRequests[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pull_requests" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pull_requests" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateRequestedByID(formats strfmt.Registry) error {

	if err := validate.Required("requested_by_id", "body", m.RequestedByID); err != nil {
		return err
	}

	if err := validate.FormatOf("requested_by_id", "body", "uuid", m.RequestedByID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateStarted(formats strfmt.Registry) error {

	if err := validate.Required("started", "body", m.Started); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateStartedAt(formats strfmt.Registry) error {

	if err := validate.Required("started_at", "body", m.StartedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("started_at", "body", "date-time", m.StartedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateStartedAtOverride(formats strfmt.Registry) error {

	if err := validate.Required("started_at_override", "body", m.StartedAtOverride); err != nil {
		return err
	}

	if err := validate.FormatOf("started_at_override", "body", "date-time", m.StartedAtOverride.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateStats(formats strfmt.Registry) error {

	if err := validate.Required("stats", "body", m.Stats); err != nil {
		return err
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *StorySearchResult) validateStoryLinks(formats strfmt.Registry) error {

	if err := validate.Required("story_links", "body", m.StoryLinks); err != nil {
		return err
	}

	for i := 0; i < len(m.StoryLinks); i++ {
		if swag.IsZero(m.StoryLinks[i]) { // not required
			continue
		}

		if m.StoryLinks[i] != nil {
			if err := m.StoryLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("story_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("story_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateStoryTemplateID(formats strfmt.Registry) error {

	if err := validate.Required("story_template_id", "body", m.StoryTemplateID); err != nil {
		return err
	}

	if err := validate.FormatOf("story_template_id", "body", "uuid", m.StoryTemplateID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateStoryType(formats strfmt.Registry) error {

	if err := validate.Required("story_type", "body", m.StoryType); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateSyncedItem(formats strfmt.Registry) error {
	if swag.IsZero(m.SyncedItem) { // not required
		return nil
	}

	if m.SyncedItem != nil {
		if err := m.SyncedItem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synced_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("synced_item")
			}
			return err
		}
	}

	return nil
}

func (m *StorySearchResult) validateTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.Tasks) { // not required
		return nil
	}

	for i := 0; i < len(m.Tasks); i++ {
		if swag.IsZero(m.Tasks[i]) { // not required
			continue
		}

		if m.Tasks[i] != nil {
			if err := m.Tasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) validateUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("updated_at", "body", m.UpdatedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateWorkflowID(formats strfmt.Registry) error {

	if err := validate.Required("workflow_id", "body", m.WorkflowID); err != nil {
		return err
	}

	return nil
}

func (m *StorySearchResult) validateWorkflowStateID(formats strfmt.Registry) error {

	if err := validate.Required("workflow_state_id", "body", m.WorkflowStateID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this story search result based on the context it is used
func (m *StorySearchResult) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBranches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCommits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkedFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePullRequests(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStoryLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSyncedItem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StorySearchResult) contextValidateBranches(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Branches); i++ {

		if m.Branches[i] != nil {

			if swag.IsZero(m.Branches[i]) { // not required
				return nil
			}

			if err := m.Branches[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("branches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("branches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateComments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Comments); i++ {

		if m.Comments[i] != nil {

			if swag.IsZero(m.Comments[i]) { // not required
				return nil
			}

			if err := m.Comments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("comments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("comments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateCommits(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Commits); i++ {

		if m.Commits[i] != nil {

			if swag.IsZero(m.Commits[i]) { // not required
				return nil
			}

			if err := m.Commits[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commits" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateCustomFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CustomFields); i++ {

		if m.CustomFields[i] != nil {

			if swag.IsZero(m.CustomFields[i]) { // not required
				return nil
			}

			if err := m.CustomFields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("custom_fields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("custom_fields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Files); i++ {

		if m.Files[i] != nil {

			if swag.IsZero(m.Files[i]) { // not required
				return nil
			}

			if err := m.Files[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Labels); i++ {

		if m.Labels[i] != nil {

			if swag.IsZero(m.Labels[i]) { // not required
				return nil
			}

			if err := m.Labels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateLinkedFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LinkedFiles); i++ {

		if m.LinkedFiles[i] != nil {

			if swag.IsZero(m.LinkedFiles[i]) { // not required
				return nil
			}

			if err := m.LinkedFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("linked_files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("linked_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidatePullRequests(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PullRequests); i++ {

		if m.PullRequests[i] != nil {

			if swag.IsZero(m.PullRequests[i]) { // not required
				return nil
			}

			if err := m.PullRequests[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pull_requests" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pull_requests" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *StorySearchResult) contextValidateStoryLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StoryLinks); i++ {

		if m.StoryLinks[i] != nil {

			if swag.IsZero(m.StoryLinks[i]) { // not required
				return nil
			}

			if err := m.StoryLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("story_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("story_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorySearchResult) contextValidateSyncedItem(ctx context.Context, formats strfmt.Registry) error {

	if m.SyncedItem != nil {

		if swag.IsZero(m.SyncedItem) { // not required
			return nil
		}

		if err := m.SyncedItem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synced_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("synced_item")
			}
			return err
		}
	}

	return nil
}

func (m *StorySearchResult) contextValidateTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tasks); i++ {

		if m.Tasks[i] != nil {

			if swag.IsZero(m.Tasks[i]) { // not required
				return nil
			}

			if err := m.Tasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *StorySearchResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StorySearchResult) UnmarshalBinary(b []byte) error {
	var res StorySearchResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
